===================================================
csvcols: a column-oriented CSV manipulation library
===================================================

This library in a nutshell::

    shipping_doc = Document.open("shipping_orders.csv")

    # Extract just the columns we care about, and rename some of them
    raw_users = shipping_doc.select("email", 
                                    ("BILLING_FIRSTNAME", "first_name"),
                                    ("BILLING_LAST_NAME", "last_name"))
    # 
    Column(map(string.lower, raw_users.email))

    Column(email.lower() for email in raw_users.email)

    raw_users.email.map(string.lower)
    raw_users.email.map(lambda s: s.lower())

    # Make a new document based on raw_users, where the email column is 
    # replaced by a copy that's been transformed into lowercase.
    users = raw_users.replace("email", raw_users.email.map(string.lower))
    sorted_users = users.sort_rows_by("email", "last_name", "first_name")
    merged_users = sorted_users.merge_if(lambda r1, r2: 
    "email")




CSV files are everywhere and every language has a library to read them row by
row. But sometimes that's not the best way to look at it. You often want to 
make manipulations, transform or make rule checks on certain columns. If you
keep the row by row model, then you just end up trying to jam everything into a
single pass over the data. Or maybe you suck up everything into a 2D data
structure and edit it in several passes. But then you start having side-effects,
and you're not sure what changed what. Then you want to add a new rule that
requires data from an older pass through the data, and you start making
temporary data structures to hold the values of special columns or rows...

Yes, I've seen this. It's been thrown on my lap, and it's a maintenance 
nightmare.

This library takes a column-oriented approach towards CSV data. Everything is
stored internally as Unicode, and everything is outwardly immutable.

History...?

